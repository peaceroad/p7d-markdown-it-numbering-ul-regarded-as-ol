// Phase 3: Attribute Addition
// Add type, class, and data-* attributes to ordered lists

import { getTypeAttributes } from './types-utility.js'
import { findMatchingClose } from './list-helpers.js'

/**
 * Add attributes to lists
 * @param {Array} tokens - Token array
 * @param {Array} listInfos - List information
 * @param {Object} opt - Options
 */
export function addAttributes(tokens, listInfos, opt) {
  // Traverse token array and add attributes to ordered_list_open tokens
  // Token array may have been rebuilt in Phase2,
  // so don't use listInfo.startIndex, check token's _markerInfo/_listInfo
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    
    if (token.type === 'ordered_list_open') {
      // Find listInfo corresponding to this token
      // Check _markerInfo or _convertedFromBullet flag saved in Phase2
      if (token._markerInfo || token._convertedFromBullet) {
        addListAttributesForToken(tokens, token, i, opt)
      } else {
        // If originally ordered_list, find from listInfos
        const listInfo = findListInfoForToken(tokens, i, listInfos)
        if (listInfo) {
          addListAttributesForToken(tokens, token, i, opt, listInfo)
        }
      }
    }
  }
  
  // Normalize value attributes of ordered_list generated by markdown-it
  // Remove unnecessary value attributes after Phase2 simplification
  // In alwaysMarkerSpan mode, convert value to data-value attribute unless useCounterStyle is enabled
  normalizeAndConvertValueAttributes(tokens, opt)
}

/**
 * Find the `listInfo` that corresponds to a given token.
 * @param {Array} tokens - Array of tokens
 * @param {number} tokenIndex - Index of the token to match
 * @param {Array} listInfos - Array of list information objects
 */
function findListInfoForToken(tokens, tokenIndex, listInfos) {
  // Find matching from listInfos
  const listInfo = listInfos.find(info => info.startIndex === tokenIndex)
  if (listInfo && listInfo.markerInfo) {
    return listInfo
  }
  
  // Return null if not found
  return null
}

/**
 * Add attributes to a single list token
 */
function addListAttributesForToken(tokens, token, tokenIndex, opt, listInfo = null) {
  // Initialize attribute array
  if (!token.attrs) {
    token.attrs = []
  }
  
  // Get marker info
  const markerInfo = token._markerInfo || listInfo?.markerInfo
  
  if (!markerInfo) {
    // Default attributes for lists without markerInfo
    if (opt.useCounterStyle) {
      // Do not add type attribute; add class and data-marker-suffix so user CSS/@counter-style can target
      addAttr(token, 'class', 'ol-decimal')
      addAttr(token, 'data-marker-suffix', '.')
      addAttr(token, 'class', 'use-counter-style')
      return
    }

    // Fallback default (legacy behavior)
    addAttr(token, 'type', '1')
    addAttr(token, 'class', 'ol-decimal')
    addAttr(token, 'data-marker-suffix', '.')
    return
  }
  
  // Attributes according to marker type
  // Pass first marker's prefix/suffix info to determine class name
  const firstMarker = markerInfo.markers[0]
  const typeAttrs = getTypeAttributes(markerInfo.type, firstMarker)
  
  // Reset attribute array
  token.attrs = []
  
  // Add attributes in expected order
  // Standard marker: type → start → class → data-marker-*
  // Custom marker: role → data-start → class → data-marker-*
  // alwaysMarkerSpan: role → data-start → class → data-marker-* (no type attribute)
  
  // 1. type attribute or role attribute (add first)
  // Always use role="list" for alwaysMarkerSpan
  if (opt.useCounterStyle) {
    // When user chooses @counter-style, we avoid role and inline styles.
    // Still add class so users can target with CSS (e.g., counter-reset/counter-increment or @counter-style usage).
    // Do not add type attribute (counter-style will handle visuals)
  } else if (typeAttrs.type && !opt.alwaysMarkerSpan) {
    addAttr(token, 'type', typeAttrs.type)
  } else {
    addAttr(token, 'role', 'list')
    if (opt.hasListStyleNone) {
      addAttr(token, 'style', 'list-style: none;')
    }
  }
  
  // 2. Add start attribute or data-start attribute
  const firstNumber = markerInfo.markers[0]?.number
  if (firstNumber !== undefined && firstNumber !== 1) {
    // If using counter-style, never add `start` attribute because `type` is omitted.
    if (typeAttrs.type && !opt.alwaysMarkerSpan && !opt.useCounterStyle) {
      // start attribute for standard marker without alwaysMarkerSpan
      addAttr(token, 'start', String(firstNumber))
    } else {
      // For useCounterStyle prefer `start` attribute so CSS counter-style can rely on native numbering
      if (opt.useCounterStyle) {
        addAttr(token, 'start', String(firstNumber))
      } else {
        // data-start attribute for custom marker or alwaysMarkerSpan
        addAttr(token, 'data-start', String(firstNumber))
      }
    }
  }
  
  // 3. Add class attribute
  if (typeAttrs.class) {
    // Merge or add class; preserve existing classes and append
    const existing = token.attrs.find(a => a[0] === 'class')
    if (existing) {
      existing[1] = (existing[1] + ' ' + typeAttrs.class).trim()
    } else {
      addAttr(token, 'class', typeAttrs.class)
    }
  }

  // If user requested @counter-style, add a helper class to identify lists
  if (opt.useCounterStyle) {
    // Do not add helper class when using counter-style; user CSS should target generated ol-* classes.
  }
  
  // 4. data-marker-prefix/suffix
  if (markerInfo.markers[0].prefix) {
    addAttr(token, 'data-marker-prefix', markerInfo.markers[0].prefix)
  }
  if (markerInfo.markers[0].suffix) {
    addAttr(token, 'data-marker-suffix', markerInfo.markers[0].suffix)
  }
  
  // Add value attribute to list items (for non-consecutive numbers)
  addListItemValues(tokens, tokenIndex, markerInfo)
}

/**
 * Add `value` attributes to list items when numbering is non-consecutive.
 * @param {Array} tokens - Array of tokens
 * @param {number} listOpenIndex - Index of the corresponding `ordered_list_open` token
 * @param {Object} markerInfo - Marker information object
 */
function addListItemValues(tokens, listOpenIndex, markerInfo) {
  if (!markerInfo || !markerInfo.markers) {
    return
  }
  
  // Find end position of this ordered_list
  const listCloseIndex = findMatchingClose(tokens, listOpenIndex, 'ordered_list_open', 'ordered_list_close')
  if (listCloseIndex === -1) return
  
  const markers = markerInfo.markers
  
  // Get start value from start attribute (if not, use first marker's number, or 1 if neither)
  const listToken = tokens[listOpenIndex]
  const startAttr = listToken.attrs?.find(attr => attr[0] === 'start')
  let expectedValue = startAttr ? parseInt(startAttr[1], 10) : (markers[0]?.number || 1)
  let markerIndex = 0
  
  // Find list_item_open and add value attribute
  for (let i = listOpenIndex + 1; i < listCloseIndex; i++) {
    const token = tokens[i]
    
    if (token.type === 'list_item_open' && token.level === tokens[listOpenIndex].level + 1) {
      const marker = markers[markerIndex]
      if (marker && marker.number !== undefined) {
        // Add value attribute only when differs from expected (number not consecutive)
        // Example: 3→4 is consecutive (unnecessary), 3→5 skips (needed), 3→2 goes back (needed)
        if (marker.number !== expectedValue) {
          if (!token.attrs) {
            token.attrs = []
          }
          addAttr(token, 'value', String(marker.number))
        }
        
        expectedValue = marker.number + 1
      } else {
        expectedValue++
      }
      markerIndex++
    }
  }
}

/**
 * Normalize value attributes generated by markdown-it for ordered lists.
 * Remove value attributes for consecutive numbers.
 * For `alwaysMarkerSpan` option, convert `value` attributes to `data-value` (unless using counter-style).
 * @param {Array} tokens - Token array
 * @param {boolean} alwaysMarkerSpan - alwaysMarkerSpan option
 */
function normalizeAndConvertValueAttributes(tokens, opt) {
  const alwaysMarkerSpan = !!opt.alwaysMarkerSpan
  const useCounterStyle = !!opt.useCounterStyle

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]

    if (token.type === 'ordered_list_open') {
      const listCloseIndex = findMatchingClose(tokens, i, 'ordered_list_open', 'ordered_list_close')
      if (listCloseIndex === -1) continue

      // Get start value from start attribute
      const startAttr = token.attrs?.find(attr => attr[0] === 'start')
      let expectedValue = startAttr ? parseInt(startAttr[1], 10) : 1

      // Process list_item_open in this list
      for (let j = i + 1; j < listCloseIndex; j++) {
        const itemToken = tokens[j]

        if (itemToken.type === 'list_item_open' && itemToken.level === token.level + 1) {
          // Check existing value attribute
          if (itemToken.attrs) {
            const valueAttrIdx = itemToken.attrs.findIndex(attr => attr[0] === 'value')
            if (valueAttrIdx !== -1) {
              const itemValue = parseInt(itemToken.attrs[valueAttrIdx][1], 10)

              // Remove value attribute if matches expected value
              if (itemValue === expectedValue) {
                itemToken.attrs.splice(valueAttrIdx, 1)
                if (itemToken.attrs.length === 0) {
                  itemToken.attrs = null
                }
              } else {
                // If differs from expected value
                // Convert value→data-value for alwaysMarkerSpan unless using counter-style
                if (alwaysMarkerSpan && !useCounterStyle) {
                  itemToken.attrs[valueAttrIdx][0] = 'data-value'
                }
                expectedValue = itemValue
              }

              expectedValue++
            } else {
              // Increment expectedValue if no value attribute
              expectedValue++
            }
          } else {
            expectedValue++
          }
        }
      }
    } else if (alwaysMarkerSpan && token.type === 'list_item_open' && token.attrs) {
      // Also convert value attributes of list_items outside ordered_list (ol>li in ul)
      const valueAttrIdx = token.attrs.findIndex(attr => attr[0] === 'value')
      if (valueAttrIdx !== -1 && !useCounterStyle) {
        token.attrs[valueAttrIdx][0] = 'data-value'
      }
    }
  }
}

/**
 * Add or replace an attribute on a token (with duplicate check).
 */
function addAttr(token, name, value) {
  const existingIndex = token.attrs.findIndex(attr => attr[0] === name)
  if (existingIndex >= 0) {
    token.attrs[existingIndex] = [name, value]
  } else {
    token.attrs.push([name, value])
  }
}
