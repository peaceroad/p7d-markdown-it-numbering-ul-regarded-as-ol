// Phase 3: Attribute Addition
// Add type, class, and data-* attributes to ordered lists

import { getTypeAttributes } from './types-utility.js'
import { findMatchingClose } from './list-helpers.js'

/**
 * Add attributes to lists
 * @param {Array} tokens - Token array
 * @param {Array} listInfos - List information
 * @param {Object} opt - Options
 */
export function addAttributes(tokens, listInfos, opt) {
  const listInfoMap = buildListInfoMap(listInfos)
  
  // Traverse token array and add attributes to ordered_list_open tokens
  // Token array may have been rebuilt in Phase2,
  // so don't use listInfo.startIndex, check token's _markerInfo/_listInfo
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    
    if (token.type === 'ordered_list_open') {
      // Find listInfo corresponding to this token
      // Check _markerInfo or _convertedFromBullet flag saved in Phase2
      if (token._markerInfo || token._convertedFromBullet) {
        addListAttributesForToken(tokens, token, i, opt)
      } else {
        // If originally ordered_list, find from listInfos
        const listInfo = listInfoMap.get(i)
        if (listInfo) {
          addListAttributesForToken(tokens, token, i, opt, listInfo)
        }
      }
    }
  }
  
  // Normalize value attributes of ordered_list generated by markdown-it
  // Remove unnecessary value attributes after Phase2 simplification
  // Normalize value attributes and marker metadata for all ordered lists
  normalizeAndConvertValueAttributes(tokens, opt)
}

/**
 * Build a lookup map for listInfos keyed by startIndex.
 */
function buildListInfoMap(listInfos) {
  if (!Array.isArray(listInfos) || listInfos.length === 0) {
    return new Map()
  }
  
  const map = new Map()
  for (const info of listInfos) {
    if (!info || typeof info.startIndex !== 'number' || !info.markerInfo) {
      continue
    }
    if (!map.has(info.startIndex)) {
      map.set(info.startIndex, info)
    }
  }
  return map
}

/**
 * Add attributes to a single list token
 */
function addListAttributesForToken(tokens, token, tokenIndex, opt, listInfo = null) {
  // Initialize attribute array
  if (!token.attrs) {
    token.attrs = []
  }
  
  // Get marker info
  const markerInfo = token._markerInfo || listInfo?.markerInfo
  
  if (!markerInfo) {
    // Default attributes for lists without markerInfo
    if (opt.useCounterStyle) {
      // Do not add type attribute; add class so user CSS/@counter-style can target
      addAttr(token, 'class', 'ol-decimal')
      if (!opt.omitMarkerMetadata) {
        addAttr(token, 'data-marker-suffix', '.')
      }
      return
    }

    // Fallback default (legacy behavior)
    addAttr(token, 'type', '1')
    addAttr(token, 'class', 'ol-decimal')
    if (!opt.omitMarkerMetadata) {
      addAttr(token, 'data-marker-suffix', '.')
    }
    return
  }
  
  // Attributes according to marker type
  // Pass first marker's prefix/suffix info to determine class name
  const firstMarker = markerInfo.markers[0]
  const typeAttrs = getTypeAttributes(markerInfo.type, firstMarker)
  
  // Reset attribute array
  token.attrs = []
  // Add attributes in expected order
  // Standard marker: type -> start -> class -> data-marker-*
  // Custom marker or alwaysMarkerSpan: role -> start -> class -> data-marker-* (no type attribute)
  
  // 1. type attribute or role attribute (add first)
  // Always use role="list" for alwaysMarkerSpan
  if (opt.useCounterStyle) {
    // When user chooses @counter-style, we avoid role and inline styles.
    // Still add class so users can target with CSS (e.g., counter-reset/counter-increment or @counter-style usage).
    // Do not add type attribute (counter-style will handle visuals)
  } else if (typeAttrs.type && !opt.alwaysMarkerSpan) {
    addAttr(token, 'type', typeAttrs.type)
  } else {
    addAttr(token, 'role', 'list')
    if (opt.hasListStyleNone) {
      addAttr(token, 'style', 'list-style: none;')
    }
  }
  
  // 2. Add start attribute when numbering doesn't begin at 1
  let startOverride = token._startOverride
  if (startOverride !== undefined && startOverride !== null) {
    const parsed = typeof startOverride === 'number' ? startOverride : parseInt(startOverride, 10)
    startOverride = Number.isNaN(parsed) ? undefined : parsed
  } else {
    startOverride = undefined
  }
  const firstNumber = startOverride ?? (markerInfo.markers[0]?.originalNumber ?? markerInfo.markers[0]?.number)
  if (firstNumber !== undefined && firstNumber !== 1) {
    addAttr(token, 'start', String(firstNumber))
  } else if (token.attrs) {
    const startIdx = token.attrs.findIndex(attr => attr[0] === 'start')
    if (startIdx >= 0) {
      token.attrs.splice(startIdx, 1)
      if (token.attrs.length === 0) token.attrs = null
    }
  }
  
  // 3. Add class attribute
  if (typeAttrs.class) {
    // Merge or add class; preserve existing classes and append
    const existing = token.attrs.find(a => a[0] === 'class')
    if (existing) {
      existing[1] = (existing[1] + ' ' + typeAttrs.class).trim()
    } else {
      addAttr(token, 'class', typeAttrs.class)
    }
  }

  // If user requested @counter-style, add a helper class to identify lists
  if (opt.useCounterStyle) {
    // Do not add helper class when using counter-style; user CSS should target generated ol-* classes.
  }
  
  // 4. data-marker-prefix/suffix
  if (!opt.omitMarkerMetadata) {
    if (markerInfo.markers[0].prefix) {
      addAttr(token, 'data-marker-prefix', markerInfo.markers[0].prefix)
    }
    // Do not emit data-marker-suffix when suffix is only whitespace (halfwidth or fullwidth)
    const suffix = markerInfo.markers[0].suffix
    if (suffix && !/^[ \u3000]+$/.test(suffix)) {
      addAttr(token, 'data-marker-suffix', suffix)
    }
  }
  
  // Add value attribute to list items (for non-consecutive numbers)
  addListItemValues(tokens, tokenIndex, markerInfo)
}

/**
 * Add `value` attributes to list items when numbering is non-consecutive.
 * @param {Array} tokens - Array of tokens
 * @param {number} listOpenIndex - Index of the corresponding `ordered_list_open` token
 * @param {Object} markerInfo - Marker information object
 */
function addListItemValues(tokens, listOpenIndex, markerInfo) {
  if (!markerInfo || !markerInfo.markers) {
    return
  }
  if (markerInfo.allNumbersIdentical) {
    return
  }
  
  // Find end position of this ordered_list
  const listCloseIndex = findMatchingClose(tokens, listOpenIndex, 'ordered_list_open', 'ordered_list_close')
  if (listCloseIndex === -1) return
  
  const markers = markerInfo.markers
  
  // Get start value from start attribute (if not, use first marker's number, or 1 if neither)
  const listToken = tokens[listOpenIndex]
  const startAttr = listToken.attrs?.find(attr => attr[0] === 'start')
  let expectedValue = startAttr ? parseInt(startAttr[1], 10) : (markers[0]?.number || 1)
  let markerIndex = 0
  
  // Find list_item_open and add value attribute
  for (let i = listOpenIndex + 1; i < listCloseIndex; i++) {
    const token = tokens[i]
    
    if (token.type === 'list_item_open' && token.level === tokens[listOpenIndex].level + 1) {
      const marker = markers[markerIndex]
      if (marker && marker.number !== undefined) {
        // Add value attribute only when differs from expected (number not consecutive)
        // Example: 3→4 is consecutive (unnecessary), 3→5 skips (needed), 3→2 goes back (needed)
        if (marker.number !== expectedValue) {
          if (!token.attrs) {
            token.attrs = []
          }
          addAttr(token, 'value', String(marker.number))
        }
        
        expectedValue = marker.number + 1
      } else {
        expectedValue++
      }
      markerIndex++
    }
  }
}

/**
 * Normalize value attributes generated by markdown-it for ordered lists.
 * Remove value attributes for consecutive numbers.
 * @param {Array} tokens - Token array
 * @param {Object} opt - Plugin options
 */
function normalizeAndConvertValueAttributes(tokens, opt) {
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]

    if (token.type === 'ordered_list_open') {
      const listCloseIndex = findMatchingClose(tokens, i, 'ordered_list_open', 'ordered_list_close')
      if (listCloseIndex === -1) continue

      // Get start value from start attribute
      const startAttr = token.attrs?.find(attr => attr[0] === 'start')
      let expectedValue = startAttr ? parseInt(startAttr[1], 10) : 1

      // Process list_item_open in this list
      for (let j = i + 1; j < listCloseIndex; j++) {
        const itemToken = tokens[j]

        if (itemToken.type === 'list_item_open' && itemToken.level === token.level + 1) {
          // Check existing value attribute
          if (itemToken.attrs) {
            const valueAttrIdx = itemToken.attrs.findIndex(attr => attr[0] === 'value')
            if (valueAttrIdx !== -1) {
              const itemValue = parseInt(itemToken.attrs[valueAttrIdx][1], 10)

              // Remove value attribute if matches expected value
              if (itemValue === expectedValue) {
                itemToken.attrs.splice(valueAttrIdx, 1)
                if (itemToken.attrs.length === 0) {
                  itemToken.attrs = null
                }
              } else {
                // If differs from expected value
                expectedValue = itemValue
              }

              expectedValue++
            } else {
              // Increment expectedValue if no value attribute
              expectedValue++
            }
          } else {
            expectedValue++
          }
        }
      }
    }
  }
}

/**
 * Add or replace an attribute on a token (with duplicate check).
 */
function addAttr(token, name, value) {
  const existingIndex = token.attrs.findIndex(attr => attr[0] === name)
  if (existingIndex >= 0) {
    token.attrs[existingIndex] = [name, value]
  } else {
    token.attrs.push([name, value])
  }
}
