// Phase 3: Attribute Addition
// Add type, class, and data-* attributes to ordered lists

import { getTypeAttributes } from './types-utility.js'
import { findMatchingClose } from './list-helpers.js'

/**
 * Add attributes to lists
 * @param {Array} tokens - Token array
 * @param {Array} listInfos - List information
 * @param {Object} opt - Options
 */
export function addAttributes(tokens, listInfos, opt) {
  // Traverse token array and add attributes to ordered_list_open tokens
  // Token array may have been rebuilt in Phase2,
  // so don't use listInfo.startIndex, check token's _markerInfo/_listInfo
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    
    if (token.type === 'ordered_list_open') {
      // Find listInfo corresponding to this token
      // Check _markerInfo or _convertedFromBullet flag saved in Phase2
      if (token._markerInfo || token._convertedFromBullet) {
        addListAttributesForToken(tokens, token, i, opt)
      } else {
        // If originally ordered_list, find from listInfos
        const listInfo = findListInfoForToken(tokens, i, listInfos)
        if (listInfo) {
          addListAttributesForToken(tokens, token, i, opt, listInfo)
        }
      }
    }
  }
  
  // Normalize value attributes of ordered_list generated by markdown-it
  // Remove unnecessary value attributes after Phase2 simplification
  // In alwaysMarkerSpan mode, convert value to data-value attribute
  normalizeAndConvertValueAttributes(tokens, opt.alwaysMarkerSpan)
}

/**
 * トークンに対応するlistInfoを探す
 * @param {Array} tokens - トークン配列
 * @param {number} tokenIndex - トークンインデックス
 * @param {Array} listInfos - リスト情報配列
 */
function findListInfoForToken(tokens, tokenIndex, listInfos) {
  // Find matching from listInfos
  const listInfo = listInfos.find(info => info.startIndex === tokenIndex)
  if (listInfo && listInfo.markerInfo) {
    return listInfo
  }
  
  // Return null if not found
  return null
}

/**
 * 単一リストトークンに属性を追加
 */
function addListAttributesForToken(tokens, token, tokenIndex, opt, listInfo = null) {
  // Initialize attribute array
  if (!token.attrs) {
    token.attrs = []
  }
  
  // Get marker info
  const markerInfo = token._markerInfo || listInfo?.markerInfo
  
  if (!markerInfo) {
    // Default attributes
    addAttr(token, 'type', '1')
    addAttr(token, 'class', 'ol-decimal')
    addAttr(token, 'data-marker-suffix', '.')
    return
  }
  
  // Attributes according to marker type
  // Pass first marker's prefix/suffix info to determine class name
  const firstMarker = markerInfo.markers[0]
  const typeAttrs = getTypeAttributes(markerInfo.type, firstMarker)
  
  // Reset attribute array
  token.attrs = []
  
  // Add attributes in expected order
  // Standard marker: type → start → class → data-marker-*
  // Custom marker: role → data-start → class → data-marker-*
  // alwaysMarkerSpan: role → data-start → class → data-marker-* (no type attribute)
  
  // 1. type attribute or role attribute (add first)
  // Always use role="list" for alwaysMarkerSpan
  if (typeAttrs.type && !opt.alwaysMarkerSpan) {
    addAttr(token, 'type', typeAttrs.type)
  } else {
    addAttr(token, 'role', 'list')
    if (opt.hasListStyleNone) {
      addAttr(token, 'style', 'list-style: none;')
    }
  }
  
  // 2. Add start attribute or data-start attribute
  const firstNumber = markerInfo.markers[0]?.number
  if (firstNumber !== undefined && firstNumber !== 1) {
    if (typeAttrs.type && !opt.alwaysMarkerSpan) {
      // start attribute for standard marker without alwaysMarkerSpan
      addAttr(token, 'start', String(firstNumber))
    } else {
      // data-start attribute for custom marker or alwaysMarkerSpan
      addAttr(token, 'data-start', String(firstNumber))
    }
  }
  
  // 3. Add class attribute
  if (typeAttrs.class) {
    addAttr(token, 'class', typeAttrs.class)
  }
  
  // 4. data-marker-prefix/suffix
  if (markerInfo.markers[0].prefix) {
    addAttr(token, 'data-marker-prefix', markerInfo.markers[0].prefix)
  }
  if (markerInfo.markers[0].suffix) {
    addAttr(token, 'data-marker-suffix', markerInfo.markers[0].suffix)
  }
  
  // Add value attribute to list items (for non-consecutive numbers)
  addListItemValues(tokens, tokenIndex, markerInfo)
}

/**
 * リスト項目にvalue属性を追加
 * @param {Array} tokens - トークン配列
 * @param {number} listOpenIndex - ordered_list_openのインデックス
 * @param {Object} markerInfo - マーカー情報
 */
function addListItemValues(tokens, listOpenIndex, markerInfo) {
  if (!markerInfo || !markerInfo.markers) {
    return
  }
  
  // Find end position of this ordered_list
  const listCloseIndex = findMatchingClose(tokens, listOpenIndex, 'ordered_list_open', 'ordered_list_close')
  if (listCloseIndex === -1) return
  
  const markers = markerInfo.markers
  
  // Get start value from start attribute (if not, use first marker's number, or 1 if neither)
  const listToken = tokens[listOpenIndex]
  const startAttr = listToken.attrs?.find(attr => attr[0] === 'start')
  let expectedValue = startAttr ? parseInt(startAttr[1], 10) : (markers[0]?.number || 1)
  let markerIndex = 0
  
  // Find list_item_open and add value attribute
  for (let i = listOpenIndex + 1; i < listCloseIndex; i++) {
    const token = tokens[i]
    
    if (token.type === 'list_item_open' && token.level === tokens[listOpenIndex].level + 1) {
      const marker = markers[markerIndex]
      if (marker && marker.number !== undefined) {
        // Add value attribute only when differs from expected (number not consecutive)
        // Example: 3→4 is consecutive (unnecessary), 3→5 skips (needed), 3→2 goes back (needed)
        if (marker.number !== expectedValue) {
          if (!token.attrs) {
            token.attrs = []
          }
          addAttr(token, 'value', String(marker.number))
        }
        
        expectedValue = marker.number + 1
      } else {
        expectedValue++
      }
      markerIndex++
    }
  }
}

/**
 * markdown-itが生成したordered_listのvalue属性を正規化
 * 連続する番号のvalue属性を削除
 * alwaysMarkerSpanオプションの場合、value属性をdata-value属性に変換
 * @param {Array} tokens - トークン配列
 * @param {boolean} alwaysMarkerSpan - alwaysMarkerSpanオプション
 */
function normalizeAndConvertValueAttributes(tokens, alwaysMarkerSpan) {
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    
    if (token.type === 'ordered_list_open') {
      const listCloseIndex = findMatchingClose(tokens, i, 'ordered_list_open', 'ordered_list_close')
      if (listCloseIndex === -1) continue
      
      // Get start value from start attribute
      const startAttr = token.attrs?.find(attr => attr[0] === 'start')
      let expectedValue = startAttr ? parseInt(startAttr[1], 10) : 1
      
      // Process list_item_open in this list
      for (let j = i + 1; j < listCloseIndex; j++) {
        const itemToken = tokens[j]
        
        if (itemToken.type === 'list_item_open' && itemToken.level === token.level + 1) {
          // Check existing value attribute
          if (itemToken.attrs) {
            const valueAttrIdx = itemToken.attrs.findIndex(attr => attr[0] === 'value')
            if (valueAttrIdx !== -1) {
              const itemValue = parseInt(itemToken.attrs[valueAttrIdx][1], 10)
              
              // Remove value attribute if matches expected value
              if (itemValue === expectedValue) {
                itemToken.attrs.splice(valueAttrIdx, 1)
                if (itemToken.attrs.length === 0) {
                  itemToken.attrs = null
                }
              } else {
                // If differs from expected value
                // Convert value→data-value for alwaysMarkerSpan
                if (alwaysMarkerSpan) {
                  itemToken.attrs[valueAttrIdx][0] = 'data-value'
                }
                expectedValue = itemValue
              }
              
              expectedValue++
            } else {
              // Increment expectedValue if no value attribute
              expectedValue++
            }
          } else {
            expectedValue++
          }
        }
      }
    } else if (alwaysMarkerSpan && token.type === 'list_item_open' && token.attrs) {
      // Also convert value attributes of list_items outside ordered_list (ol>li in ul)
      const valueAttrIdx = token.attrs.findIndex(attr => attr[0] === 'value')
      if (valueAttrIdx !== -1) {
        token.attrs[valueAttrIdx][0] = 'data-value'
      }
    }
  }
}

/**
 * 属性を追加（重複チェック付き）
 */
function addAttr(token, name, value) {
  const existingIndex = token.attrs.findIndex(attr => attr[0] === name)
  if (existingIndex >= 0) {
    token.attrs[existingIndex] = [name, value]
  } else {
    token.attrs.push([name, value])
  }
}
